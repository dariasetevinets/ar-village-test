<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Daria Setevinets x TwinPlyos</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">

    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        .status {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            text-align: center;
            color: white;
            font-family: Arial;
            z-index: 100;
        }
    </style>
</head>
    
<body>
    <div class="status">Наведите камеру на маркер</div>
    
    <a-scene
        vr-mode-ui="enabled: false"
        embedded
        arjs="sourceType: webcam; detectionMode: mono_and_matrix; matrixCodeType: 3x3; cameraParametersUrl: https://raw.githack.com/AR-js-org/AR.js/master/data/data/camera_para.dat"
    >
        <a-assets>
            <img id="drawing1" src="https://dariasetevinets.github.io/ar-village-test/assets/drawings/setevinets_index-1.png" crossorigin="anonymous">
            <script id="antsVertShader" type="x-shader/x-vertex">
                varying vec2 vUv;
                void main() {
                  vUv = uv;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            </script>
            
            <script id="antsFragShader" type="x-shader/x-fragment">
                uniform sampler2D map;
                uniform float time;
                varying vec2 vUv;
                
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                float snoise(vec3 v) {
                  const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                  vec3 i = floor(v + dot(v, C.yyy));
                  vec3 x0 = v - i + dot(i, C.xxx));
                  vec3 g = step(x0.yzx, x0.xyz);
                  vec3 l = 1.0 - g;
                  vec3 i1 = min(g.xyz, l.zxy);
                  vec3 i2 = max(g.xyz, l.zxy);
                  vec3 x1 = x0 - i1 + C.xxx;
                  vec3 x2 = x0 - i2 + C.yyy;
                  vec3 x3 = x0 - 0.5;
                  i = mod289(i);
                  vec4 p = permute(permute(permute(
                           i.z + vec4(0.0, i1.z, i2.z, 1.0))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                  vec4 j = p - 49.0 * floor(p * (1.0 / 49.0));
                  vec4 x_ = floor(j * (1.0 / 7.0));
                  vec4 y_ = floor(j - 7.0 * x_);
                  vec4 x = (x_ * 2.0 + 0.5) / 7.0 - 1.0;
                  vec4 y = (y_ * 2.0 + 0.5) / 7.0 - 1.0;
                  vec4 h = 1.0 - abs(x) - abs(y);
                  vec4 b0 = vec4(x.xy, y.xy);
                  vec4 b1 = vec4(x.zw, y.zw);
                  vec4 s0 = floor(b0)*2.0 + 1.0;
                  vec4 s1 = floor(b1)*2.0 + 1.0;
                  vec4 sh = -step(h, vec4(0.0));
                  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                  vec3 g0 = vec3(a0.xy,h.x);
                  vec3 g1 = vec3(a0.zw,h.y);
                  vec3 g2 = vec3(a1.xy,h.z);
                  vec3 g3 = vec3(a1.zw,h.w);
                  vec4 norm = inversesqrt(vec4(dot(g0,g0), dot(g1,g1), dot(g2,g2), dot(g3,g3)));
                  g0 *= norm.x;
                  g1 *= norm.y;
                  g2 *= norm.z;
                  g3 *= norm.w;
                  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                  return 42.0 * dot(m*m*m, vec4(dot(g0,x0), dot(g1,x1), 
                                            dot(g2,x2), dot(g3,x3)));
                }
                
                void main() {
                  vec2 uv = vUv;

                  float ants = 0.0;
                  for (int i = 0; i < 5; i++) {
                    float fi = float(i);
                    vec2 offset = vec2(
                      snoise(vec3(uv * 30.0, time * 0.5 + fi * 100.0)) * 0.02,
                      snoise(vec3(uv * 30.0 + 100.0, time * 0.5 + fi * 100.0)) * 0.02
                    );
                    ants += snoise(vec3(uv * 100.0 + offset, time * 2.0 + fi)) * 0.2;
                  }
                  vec3 antsColor = mix(vec3(0.1, 0.05, 0.0), vec3(0.3, 0.2, 0.1), ants);
    
                  vec4 tex = texture2D(map, uv);
                  float mask = smoothstep(0.3, 0.8, tex.a);
                  gl_FragColor = vec4(mix(tex.rgb, antsColor, ants * mask), tex.a);
                }
            </script>
        </a-assets>

        <script>
            AFRAME.registerComponent('ants-effect', {
                schema: {
                    speed: {type: 'number', default: 1.0},
                    density: {type: 'number', default: 30.0}
                },
                init: function() {
                    const textureLoader = new THREE.TextureLoader();
                    const texture = textureLoader.load(document.querySelector('#drawing1').src);  <!-- Исправлено: было #card, должно быть #drawing1 -->
                    
                    this.material = new THREE.ShaderMaterial({
                        uniforms: {
                            map: {value: texture},
                            time: {value: 0},
                            density: {value: this.data.density}
                        },
                        vertexShader: document.querySelector('#antsVertShader').textContent,
                        fragmentShader: document.querySelector('#antsFragShader').textContent,
                        transparent: true
                    });
                    
                    this.el.object3D.children[0].material = this.material;
                },
                tick: function(time) {
                    this.material.uniforms.time.value = time / 1000 * this.data.speed;
                }
            });
        </script>

        <a-marker type="pattern" url="https://dariasetevinets.github.io/ar-village-test/assets/patterns/sdxtp-1.patt" size="0.05">  <!-- Удалена лишняя точка в имени файла -->
            <a-entity
                geometry="primitive: plane; width: 0.21; height: 0.148"
                position="-2.2 0 -1.3"
                scale="15 15 1"
                rotation="-90 0 0"
                ants-effect="speed: 1.5; density: 40"
                material="shader: flat; transparent: true"
            ></a-entity>
        </a-marker>

        <a-entity camera></a-entity>
    </a-scene>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const statusEl = document.querySelector('.status');
            const scene = document.querySelector('a-scene');
            
            scene.addEventListener('markerFound', () => {
                statusEl.textContent = "Маркер распознан!";
            });

            scene.addEventListener('markerLost', () => {
                statusEl.textContent = "Наведите камеру на маркер";
            });
        });
    </script>
</body>
</html>